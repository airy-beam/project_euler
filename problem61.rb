#Problem 61
#
#Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
#all figurate (polygonal) numbers and are generated by the following formulae:
#Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
#Square 	  	P4,n=n2 	  	1, 4, 9, 16, 25, ...
#Pentagonal 	  	P5,n=n(3n−1)/2 	  	1, 5, 12, 22, 35, ...
#Hexagonal 	  	P6,n=n(2n−1) 	  	1, 6, 15, 28, 45, ...
#Heptagonal 	  	P7,n=n(5n−3)/2 	  	1, 7, 18, 34, 55, ...
#Octagonal 	  	P8,n=n(3n−2) 	  	1, 8, 21, 40, 65, ...
#
#The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
#interesting properties.
#
#The set is cyclic, in that the last two digits of each number is the first
#two digits of the next number (including the last number with the first).
#Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
#pentagonal (P5,44=2882), is represented by a different number in the set.
#This is the only set of 4-digit numbers with this property.
#
#Find the sum of the only ordered set of six cyclic 4-digit numbers for
#which each polygonal type: triangle, square, pentagonal, hexagonal,
#heptagonal, and octagonal, is represented by a different number in the set.
#

def polygonal_numbers_generator(f, n)
  case f
  when 3
    polygonal_numbers_generator = n * ( n + 1 ) / 2
  when 4
    polygonal_numbers_generator = n * n
  when 5
    polygonal_numbers_generator = n * ( 3 * n - 1 ) / 2
  when 6
    polygonal_numbers_generator = n * ( 2 * n - 1 )
  when 7
    polygonal_numbers_generator = n * ( 5 * n - 3 ) / 2
  when 8
    polygonal_numbers_generator = n * ( 3 * n - 2 )
  end
end

def go(figures_taken)
  3.upto( 8 ) { | figure |
    if not @@found
      if not @@took[ figure ] then
        @@took[ figure ] = true
        ( @@start_indices[ figure ] ).upto( @@end_indices[ figure ] ) { | index |
          if not @@found
            if ( 0 < figures_taken ) and ( figures_taken < 5 ) then
              last_two_digits_of_prev = ( @@set_of_six[ figures_taken - 1 ] ).modulo(100)
              if (last_two_digits_of_prev != 0 ) and
                  ( @@polygonal_numbers[ index ][ 1 ] / 100 == last_two_digits_of_prev ) then
                @@set_of_six << @@polygonal_numbers[ index ][ 1 ]
                go(figures_taken + 1)
                @@set_of_six.pop
              end
            else
              if ( 0 == figures_taken ) then
                @@set_of_six << @@polygonal_numbers[ index ][ 1 ]
                go(figures_taken + 1)
                @@set_of_six.pop
              else
                if ( 5 == figures_taken ) then
                  last_two_digits_of_prev = ( @@set_of_six[ figures_taken - 1 ] ).modulo(100)
                  first_two_digits_of_first = ( @@set_of_six[ 0 ] ) / 100
                  if (last_two_digits_of_prev != 0 ) and
                      ( @@polygonal_numbers[ index ][ 1 ] / 100 == last_two_digits_of_prev ) and
                      ( @@polygonal_numbers[ index ][ 1 ].modulo(100) == first_two_digits_of_first ) then
                    @@set_of_six << @@polygonal_numbers[ index ][ 1 ]
                    sum = 0
                    0.upto(5) { |i| sum += @@set_of_six[ i ] }
                    print sum, "\n"
                    @@found = true
                  end
                end
              end
            end
          end
        }
        @@took[ figure ] = false
      end
    end
  }
end

@@polygonal_numbers = [ ]
@@start_indices = [ ]
@@end_indices = [ ]
polygonal_numbers_count = 0
3.upto( 8 ) { | figure |
  @@start_indices[ figure ] = polygonal_numbers_count
  n = 1
  begin
    triangular_number = polygonal_numbers_generator( figure, n )
    if 1_000 <= triangular_number and triangular_number <= 9_999 then
      @@polygonal_numbers << [ figure, triangular_number ]
      polygonal_numbers_count += 1
    end
    n += 1
  end while triangular_number <= 9_999
  @@end_indices[ figure ] = polygonal_numbers_count - 1
}

@@found = false
@@took = [ ]
@@set_of_six = [ ]
3.upto( 8 ) { | figure | @@took[ figure ] = false }
go(0)
